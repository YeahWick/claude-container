#!/usr/bin/env python3
"""Universal plugin socket client.

Connects to plugin sockets and forwards commands for execution.

Usage:
    plugin-client <socket_path> [args...]
    plugin-client --list
    plugin-client --health <socket_path>
    plugin-client --capabilities <socket_path>
"""

import json
import os
import socket
import struct
import sys
from pathlib import Path

PLUGINS_DIR = '/run/plugins'
MAX_MESSAGE_SIZE = 64 * 1024
LENGTH_PREFIX_SIZE = 4


def encode_message(data: dict) -> bytes:
    """Encode a dictionary as a length-prefixed JSON message."""
    payload = json.dumps(data, separators=(',', ':')).encode('utf-8')
    if len(payload) > MAX_MESSAGE_SIZE:
        raise ValueError(f"Message too large: {len(payload)} bytes")
    length_prefix = struct.pack('>I', len(payload))
    return length_prefix + payload


def read_message(sock) -> dict:
    """Read a complete message from socket."""
    # Read length prefix
    data = bytearray()
    while len(data) < LENGTH_PREFIX_SIZE:
        chunk = sock.recv(LENGTH_PREFIX_SIZE - len(data))
        if not chunk:
            raise ConnectionError("Connection closed")
        data.extend(chunk)

    length = struct.unpack('>I', bytes(data))[0]
    if length > MAX_MESSAGE_SIZE:
        raise ValueError(f"Message too large: {length} bytes")

    # Read payload
    data = bytearray()
    while len(data) < length:
        chunk = sock.recv(length - len(data))
        if not chunk:
            raise ConnectionError("Connection closed during read")
        data.extend(chunk)

    return json.loads(data.decode('utf-8'))


def connect_and_send(socket_path: str, request: dict) -> dict:
    """Connect to socket and send request.

    Args:
        socket_path: Path to Unix domain socket
        request: Request dictionary

    Returns:
        Response dictionary
    """
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        sock.connect(socket_path)
        sock.sendall(encode_message(request))
        return read_message(sock)
    finally:
        sock.close()


def list_plugins():
    """List available plugins and their status."""
    plugins_path = Path(PLUGINS_DIR)
    if not plugins_path.exists():
        print(f"Plugins directory not found: {PLUGINS_DIR}", file=sys.stderr)
        return 1

    print("Available plugins:")
    print()

    found = False
    for sock_file in sorted(plugins_path.glob('*.sock')):
        found = True
        name = sock_file.stem
        status = "connected" if check_socket(str(sock_file)) else "not available"
        symbol = "+" if status == "connected" else "-"
        print(f"  {symbol} {name:12} {sock_file}  ({status})")

    if not found:
        print("  (no plugins installed)")

    return 0


def check_socket(socket_path: str) -> bool:
    """Check if socket is connectable."""
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.settimeout(1.0)
        sock.connect(socket_path)
        sock.close()
        return True
    except Exception:
        return False


def show_health(socket_path: str) -> int:
    """Show plugin health status."""
    try:
        response = connect_and_send(socket_path, {'action': 'health'})
        print(json.dumps(response, indent=2))
        return 0 if response.get('success') else 1
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def show_capabilities(socket_path: str) -> int:
    """Show plugin capabilities."""
    try:
        response = connect_and_send(socket_path, {'action': 'capabilities'})
        print(json.dumps(response, indent=2))
        return 0 if response.get('success') else 1
    except Exception as e:
        print(f"Error: {e}", file=sys.stderr)
        return 1


def execute_command(socket_path: str, args: list) -> int:
    """Execute command through plugin.

    Args:
        socket_path: Path to plugin socket
        args: Command arguments

    Returns:
        Exit code from plugin
    """
    request = {
        'action': 'exec',
        'args': args,
        'cwd': os.getcwd(),
        'env': {},
    }

    try:
        response = connect_and_send(socket_path, request)
    except FileNotFoundError:
        print(f"error: plugin socket not found: {socket_path}", file=sys.stderr)
        print("hint: is the plugin container running?", file=sys.stderr)
        return 127
    except ConnectionRefusedError:
        print(f"error: plugin not responding: {socket_path}", file=sys.stderr)
        return 127
    except Exception as e:
        print(f"error: {e}", file=sys.stderr)
        return 1

    # Handle error response
    if 'error' in response and response.get('error'):
        print(f"error: {response['error']}", file=sys.stderr)

    # Output stdout/stderr
    if response.get('stdout'):
        print(response['stdout'], end='')
    if response.get('stderr'):
        print(response['stderr'], end='', file=sys.stderr)

    return response.get('exit_code', 1)


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print(__doc__, file=sys.stderr)
        return 1

    # Handle special flags
    if sys.argv[1] == '--list':
        return list_plugins()

    if sys.argv[1] == '--health':
        if len(sys.argv) < 3:
            print("error: --health requires socket path", file=sys.stderr)
            return 1
        return show_health(sys.argv[2])

    if sys.argv[1] == '--capabilities':
        if len(sys.argv) < 3:
            print("error: --capabilities requires socket path", file=sys.stderr)
            return 1
        return show_capabilities(sys.argv[2])

    if sys.argv[1] == '--help' or sys.argv[1] == '-h':
        print(__doc__)
        return 0

    # Regular command execution
    socket_path = sys.argv[1]
    args = sys.argv[2:]

    return execute_command(socket_path, args)


if __name__ == '__main__':
    sys.exit(main())
