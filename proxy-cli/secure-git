#!/bin/bash
# Claude Code - Secure Git Wrapper
# Executes git commands with credentials injected from the credential agent
#
# Credentials are fetched just-in-time from the socket-based credential agent
# and injected only into the git subprocess environment.

set -e

# Configuration
CRED_SOCKET="${CRED_AGENT_SOCKET:-/run/agent/cred.sock}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m'

print_error() {
    echo -e "${RED}Error: $1${NC}" >&2
}

print_info() {
    echo -e "${YELLOW}$1${NC}" >&2
}

# Check if socket exists
check_socket() {
    if [ ! -S "$CRED_SOCKET" ]; then
        print_error "Credential agent socket not found at ${CRED_SOCKET}"
        echo "Make sure the credential agent container is running." >&2
        echo "Falling back to unauthenticated git..." >&2
        return 1
    fi
    return 0
}

# Get credentials from agent via socket
get_credentials() {
    local response

    if command -v python3 &> /dev/null; then
        response=$(python3 -c "
import socket
import json

sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.settimeout(5)
try:
    sock.connect('$CRED_SOCKET')
    sock.send(json.dumps({'action': 'inject', 'tool': 'github'}).encode())
    response = sock.recv(8192).decode()
    sock.close()
    print(response)
except Exception as e:
    print(json.dumps({'error': str(e)}))
" 2>/dev/null)
    elif command -v socat &> /dev/null; then
        response=$(echo '{"action": "inject", "tool": "github"}' | socat -t5 - UNIX-CONNECT:"$CRED_SOCKET" 2>/dev/null)
    else
        print_error "No socket client available (python3 or socat required)"
        return 1
    fi

    # Check for error
    if echo "$response" | grep -q '"error"'; then
        if command -v jq &> /dev/null; then
            print_error "$(echo "$response" | jq -r '.error')"
        else
            print_error "Failed to get credentials"
        fi
        return 1
    fi

    echo "$response"
}

# Extract environment variables from JSON response
extract_env() {
    local json="$1"

    if command -v jq &> /dev/null; then
        # Use jq to extract env vars
        echo "$json" | jq -r '.env | to_entries | .[] | "\(.key)=\(.value)"'
    else
        # Fallback: basic parsing (less reliable)
        echo "$json" | grep -o '"[A-Z_]*":"[^"]*"' | sed 's/"//g' | tr ':' '='
    fi
}

# Run git with injected credentials
run_git_with_creds() {
    local creds_json
    creds_json=$(get_credentials)

    if [ $? -ne 0 ] || [ -z "$creds_json" ]; then
        print_info "Running git without credentials..."
        exec git "$@"
    fi

    # Extract and export credentials to subprocess only
    local env_vars
    env_vars=$(extract_env "$creds_json")

    if [ -z "$env_vars" ]; then
        print_info "No credentials available, running git without auth..."
        exec git "$@"
    fi

    # Build environment for subprocess
    # Credentials only exist in this subprocess, not the parent shell
    (
        while IFS='=' read -r key value; do
            export "$key=$value"
        done <<< "$env_vars"

        # Run git with credentials in environment
        exec git "$@"
    )
}

# Check if this is an operation that needs credentials
needs_credentials() {
    local cmd="$1"
    case "$cmd" in
        push|pull|fetch|clone|ls-remote)
            return 0
            ;;
        *)
            return 1
            ;;
    esac
}

# Main
main() {
    if [ $# -eq 0 ]; then
        exec git
    fi

    local cmd="$1"

    # Check if we need credentials for this operation
    if needs_credentials "$cmd" && check_socket; then
        run_git_with_creds "$@"
    else
        # No credentials needed, run git directly
        exec git "$@"
    fi
}

main "$@"
