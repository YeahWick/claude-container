"""Git plugin implementation with commit hook enforcement.

This plugin enforces git restrictions through two mechanisms:
1. Pre-execution validation in the plugin server
2. Git hooks installed in repositories for first-class enforcement

Using git hooks provides defense-in-depth: even if the plugin
validation is bypassed, git itself enforces the rules.
"""

import fnmatch
import os
import re
import subprocess
import shutil
from pathlib import Path
from typing import Any, Optional

import sys
sys.path.insert(0, str(Path(__file__).parent.parent))
from base import PluginServer


class GitPlugin(PluginServer):
    """Git plugin with hook-based enforcement.

    Enforces:
    - Branch protection (blocked branches, allowed patterns)
    - Command restrictions (blocked subcommands)
    - Push restrictions (force push, delete remote)
    """

    # Template directory for git hooks
    HOOKS_TEMPLATE_DIR = '/var/lib/git-plugin/hooks'

    def __init__(self, socket_path: str, config: Optional[dict[str, Any]] = None):
        super().__init__(socket_path, 'git', config)

        # Load rules from config
        rules = self.config.get('rules', {})
        self.blocked_branches = rules.get('blocked_branches', ['main', 'master'])
        self.allowed_branch_patterns = rules.get('allowed_branch_patterns', ['claude/*', 'feature/*', 'fix/*'])
        self.blocked_subcommands = rules.get('blocked_subcommands', [])
        self.allow_force_push = rules.get('allow_force_push', False)
        self.allow_delete_remote = rules.get('allow_delete_remote', False)

        # Setup hooks template directory
        self._setup_hooks_template()

    def _setup_hooks_template(self) -> None:
        """Create git hooks template directory with enforcement hooks."""
        hooks_dir = Path(self.HOOKS_TEMPLATE_DIR)
        hooks_dir.mkdir(parents=True, exist_ok=True)

        # Create pre-push hook for branch protection
        pre_push_hook = hooks_dir / 'pre-push'
        pre_push_content = self._generate_pre_push_hook()
        pre_push_hook.write_text(pre_push_content)
        pre_push_hook.chmod(0o755)

        # Create pre-commit hook (placeholder for future checks)
        pre_commit_hook = hooks_dir / 'pre-commit'
        pre_commit_content = self._generate_pre_commit_hook()
        pre_commit_hook.write_text(pre_commit_content)
        pre_commit_hook.chmod(0o755)

        # Create commit-msg hook (placeholder for message validation)
        commit_msg_hook = hooks_dir / 'commit-msg'
        commit_msg_content = self._generate_commit_msg_hook()
        commit_msg_hook.write_text(commit_msg_content)
        commit_msg_hook.chmod(0o755)

    def _generate_pre_push_hook(self) -> str:
        """Generate pre-push hook script for branch protection."""
        blocked = ' '.join(f'"{b}"' for b in self.blocked_branches)
        allowed_patterns = ' '.join(f'"{p}"' for p in self.allowed_branch_patterns)
        allow_force = 'true' if self.allow_force_push else 'false'
        allow_delete = 'true' if self.allow_delete_remote else 'false'

        return f'''#!/bin/sh
# Git pre-push hook - enforces branch protection rules
# Generated by git-plugin

BLOCKED_BRANCHES=({blocked})
ALLOWED_PATTERNS=({allowed_patterns})
ALLOW_FORCE_PUSH={allow_force}
ALLOW_DELETE_REMOTE={allow_delete}

remote="$1"
url="$2"

# Read stdin for ref information
while read local_ref local_sha remote_ref remote_sha; do
    # Extract branch name from ref
    branch=$(echo "$remote_ref" | sed 's|refs/heads/||')

    # Check for delete operation (local_sha is all zeros)
    if [ "$local_sha" = "0000000000000000000000000000000000000000" ]; then
        if [ "$ALLOW_DELETE_REMOTE" = "false" ]; then
            echo "ERROR: Deleting remote branches is not allowed" >&2
            exit 1
        fi
        continue
    fi

    # Check blocked branches
    for blocked in "${{BLOCKED_BRANCHES[@]}}"; do
        # Handle glob patterns
        case "$branch" in
            $blocked)
                echo "ERROR: Pushing to protected branch '$branch' is not allowed" >&2
                echo "HINT: Create a feature branch matching pattern: ${{ALLOWED_PATTERNS[*]}}" >&2
                exit 1
                ;;
        esac
    done

    # Check force push (if remote_sha is not all zeros, check for force push)
    if [ "$remote_sha" != "0000000000000000000000000000000000000000" ]; then
        if [ "$ALLOW_FORCE_PUSH" = "false" ]; then
            # Check if this is a force push by seeing if remote_sha is ancestor of local_sha
            if ! git merge-base --is-ancestor "$remote_sha" "$local_sha" 2>/dev/null; then
                echo "ERROR: Force push is not allowed" >&2
                exit 1
            fi
        fi
    fi
done

exit 0
'''

    def _generate_pre_commit_hook(self) -> str:
        """Generate pre-commit hook script."""
        return '''#!/bin/sh
# Git pre-commit hook
# Generated by git-plugin

# Placeholder for future pre-commit checks
# - File size limits
# - Forbidden patterns (secrets, keys)
# - Code formatting

exit 0
'''

    def _generate_commit_msg_hook(self) -> str:
        """Generate commit-msg hook script."""
        return '''#!/bin/sh
# Git commit-msg hook
# Generated by git-plugin

# Placeholder for future commit message validation
# - Required prefixes
# - Length limits
# - Conventional commits format

exit 0
'''

    def _install_hooks(self, repo_path: str) -> None:
        """Install git hooks into a repository.

        Args:
            repo_path: Path to the git repository
        """
        git_dir = Path(repo_path) / '.git'
        if not git_dir.exists():
            return

        hooks_dir = git_dir / 'hooks'
        hooks_dir.mkdir(exist_ok=True)

        # Copy hooks from template
        template_dir = Path(self.HOOKS_TEMPLATE_DIR)
        if template_dir.exists():
            for hook in template_dir.iterdir():
                dest = hooks_dir / hook.name
                shutil.copy2(hook, dest)
                dest.chmod(0o755)

    def validate(self, args: list[str], cwd: str) -> tuple[bool, str]:
        """Validate git command before execution.

        Args:
            args: Git command arguments
            cwd: Working directory

        Returns:
            Tuple of (allowed, reason)
        """
        if not args:
            return True, ""

        # Check blocked subcommands
        cmd_str = ' '.join(args)
        for blocked in self.blocked_subcommands:
            if cmd_str.startswith(blocked) or f' {blocked}' in f' {cmd_str}':
                return False, f"Subcommand '{blocked}' is not allowed"

        # Check push command for force push flags
        if args[0] == 'push':
            if not self.allow_force_push:
                force_flags = ['-f', '--force', '--force-with-lease']
                for flag in force_flags:
                    if flag in args:
                        return False, "Force push is not allowed"

            # Check for delete with -d flag
            if not self.allow_delete_remote:
                if '-d' in args or '--delete' in args:
                    return False, "Deleting remote branches is not allowed"

            # Check target branch
            for arg in args[1:]:
                if not arg.startswith('-'):
                    # Could be remote or branch
                    # Check if it matches blocked branches
                    for blocked in self.blocked_branches:
                        if fnmatch.fnmatch(arg, blocked):
                            return False, f"Pushing to protected branch '{arg}' is not allowed"
                    break

        # Check checkout/switch for branch creation
        if args[0] in ('checkout', 'switch'):
            if '-b' in args or '-B' in args or '--create' in args:
                # Find branch name (after -b flag)
                try:
                    idx = args.index('-b') if '-b' in args else \
                          args.index('-B') if '-B' in args else \
                          args.index('--create')
                    if idx + 1 < len(args):
                        branch_name = args[idx + 1]
                        # Validate branch name matches allowed patterns
                        if self.allowed_branch_patterns:
                            matched = any(
                                fnmatch.fnmatch(branch_name, pattern)
                                for pattern in self.allowed_branch_patterns
                            )
                            if not matched:
                                return False, (
                                    f"Branch name '{branch_name}' does not match allowed patterns: "
                                    f"{', '.join(self.allowed_branch_patterns)}"
                                )
                except ValueError:
                    pass

        return True, ""

    def execute(self, args: list[str], cwd: str, env: dict[str, str]) -> dict[str, Any]:
        """Execute git command.

        Args:
            args: Git command arguments
            cwd: Working directory
            env: Additional environment variables

        Returns:
            Dictionary with exit_code, stdout, stderr
        """
        # Build environment with credentials
        full_env = os.environ.copy()
        full_env.update(env)

        # Add credentials
        cred_env = self.credentials.get_env_dict(['GITHUB_TOKEN', 'GIT_TOKEN', 'GH_TOKEN'])
        full_env.update(cred_env)

        # Configure git to use our hooks template
        full_env['GIT_TEMPLATE_DIR'] = self.HOOKS_TEMPLATE_DIR

        # Build command
        cmd = ['git'] + args

        try:
            result = subprocess.run(
                cmd,
                cwd=cwd,
                env=full_env,
                capture_output=True,
                timeout=self._timeout,
            )

            stdout = result.stdout.decode('utf-8', errors='replace')
            stderr = result.stderr.decode('utf-8', errors='replace')

            # Truncate output if too large
            if len(stdout) > self._max_output:
                stdout = stdout[:self._max_output] + '\n... (output truncated)'
            if len(stderr) > self._max_output:
                stderr = stderr[:self._max_output] + '\n... (output truncated)'

            # Install hooks after init/clone
            if args and args[0] in ('init', 'clone'):
                repo_path = cwd
                if args[0] == 'clone' and len(args) > 1:
                    # Clone destination is last non-flag argument
                    for arg in reversed(args[1:]):
                        if not arg.startswith('-'):
                            if not arg.startswith('http') and not arg.startswith('git@'):
                                repo_path = os.path.join(cwd, arg)
                            break
                self._install_hooks(repo_path)

            return {
                'exit_code': result.returncode,
                'stdout': stdout,
                'stderr': stderr,
            }

        except subprocess.TimeoutExpired:
            return {
                'exit_code': 124,
                'stdout': '',
                'stderr': f'Command timed out after {self._timeout} seconds',
            }
        except Exception as e:
            return {
                'exit_code': 1,
                'stdout': '',
                'stderr': str(e),
            }

    def health(self) -> dict[str, Any]:
        """Return health status."""
        try:
            result = subprocess.run(
                ['git', '--version'],
                capture_output=True,
                timeout=5,
            )
            version = result.stdout.decode().strip()
            return {
                'success': True,
                'status': 'healthy',
                'version': version,
                'credentials_loaded': self.credentials.has('GITHUB_TOKEN') or
                                     self.credentials.has('GH_TOKEN'),
                'hooks_installed': Path(self.HOOKS_TEMPLATE_DIR).exists(),
            }
        except Exception as e:
            return {
                'success': False,
                'status': 'unhealthy',
                'error': str(e),
            }

    def capabilities(self) -> dict[str, Any]:
        """Return what operations are allowed."""
        return {
            'success': True,
            'tool': 'git',
            'rules': {
                'blocked_branches': self.blocked_branches,
                'allowed_branch_patterns': self.allowed_branch_patterns,
                'blocked_subcommands': self.blocked_subcommands,
                'allow_force_push': self.allow_force_push,
                'allow_delete_remote': self.allow_delete_remote,
            },
            'enforcement': {
                'pre_execution_validation': True,
                'git_hooks': ['pre-push', 'pre-commit', 'commit-msg'],
            },
        }
