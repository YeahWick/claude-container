#!/usr/bin/env python3
"""Tool client - forwards commands to the tool server for execution.

Detects tool name from argv[0] (supports symlinks).
All validation and restrictions are enforced server-side.

Symlinks are auto-generated by the container entrypoint from tools.d/.
"""

import json
import logging
import os
import socket
import struct
import sys

logger = logging.getLogger('tool-client')

MAX_MSG = 64 * 1024


def main():
    logging.basicConfig(
        level=logging.WARNING,
        format='%(name)s: %(message)s',
        stream=sys.stderr,
    )

    # Socket path must be set via environment for concurrent instance support
    socket_path = os.environ.get('TOOL_SOCKET')
    if not socket_path:
        logger.error('TOOL_SOCKET environment variable not set')
        return 1

    tool = os.path.basename(sys.argv[0])
    args = sys.argv[1:]

    request = {
        'tool': tool,
        'args': args,
        'cwd': os.getcwd(),
    }

    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.connect(socket_path)

        # Send request (length-prefixed JSON)
        payload = json.dumps(request).encode()
        sock.sendall(struct.pack('>I', len(payload)) + payload)

        # Read response length
        length_data = sock.recv(4)
        if len(length_data) < 4:
            logger.error('Server closed connection before responding')
            return 1
        length = struct.unpack('>I', length_data)[0]

        # Read response
        data = b''
        while len(data) < length:
            chunk = sock.recv(min(4096, length - len(data)))
            if not chunk:
                break
            data += chunk
        sock.close()

        response = json.loads(data)

    except FileNotFoundError:
        logger.error(f'Server socket not found: {socket_path}')
        return 127
    except ConnectionRefusedError:
        logger.error(f'Server not responding on: {socket_path}')
        return 127
    except Exception as e:
        logger.error(f'Communication failed: {type(e).__name__}: {e}')
        return 1

    # Output
    if response.get('error'):
        logger.error(response['error'])
    if response.get('stdout'):
        sys.stdout.write(response['stdout'])
    if response.get('stderr'):
        sys.stderr.write(response['stderr'])

    return response.get('exit_code', 1)


if __name__ == '__main__':
    sys.exit(main())
